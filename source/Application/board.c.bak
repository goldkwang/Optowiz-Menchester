/*******************************************************************************
 * Copyright (C) 2018 Maxim Integrated Products, Inc., All rights Reserved.
 * * This software is protected by copyright laws of the United States and
 * of foreign countries. This material may also be protected by patent laws
 * and technology transfer regulations of the United States and of foreign
 * countries. This software is furnished under a license agreement and/or a
 * nondisclosure agreement and may only be used or reproduced in accordance
 * with the terms of those agreements. Dissemination of this information to
 * any party or parties not specified in the license agreement and/or
 * nondisclosure agreement is expressly prohibited.
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL MAXIM INTEGRATED BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of Maxim Integrated
 * Products, Inc. shall not be used except as stated in the Maxim Integrated
 * Products, Inc. Branding Policy.
 *
 * The mere transfer of this software does not imply any licenses
 * of trade secrets, proprietary technology, copyrights, patents,
 * trademarks, maskwork rights, or any other form of intellectual
 * property whatsoever. Maxim Integrated Products, Inc. retains all
 * ownership rights.
 *******************************************************************************
 */

//-----------------------------------------------------------------------------
// Includes
//-----------------------------------------------------------------------------
#include <intrinsics.h>
#include <iods4835.h>
#include "includes.h"

//-----------------------------------------------------------------------------
// local variables defined in this module
//-----------------------------------------------------------------------------
static unsigned int s_unWaiting_I2C = 0x0000;

#if __HSFP_10G_MULTI_RATE_SEMI_TUNABLE__ == 1
#else
#endif

//-----------------------------------------------------------------------------
// TXD ISR function
//   - TXD interrupt service routine
//-----------------------------------------------------------------------------
#pragma vector = 0
__interrupt void TXD_Interrupt(void)
{
#if __SFP28_ER__ == 1
#if __SFP28_ER_SEMI_TUNABLE__ == 1

  SW_Delay(2); // delay for tx disable signal stable.

  if (EIF2_bit.EIF24 == 1) // TX disable, GP24
  {

    EIF2_bit.EIF24 = 0; // clear flag

    if (EIES2_bit.EIES24 == 0) // if the interrupt is generated by rising edge
    {

      if (PI2_bit.PI24 == 1) // if tx_disable input is high
      {
        EIES2_bit.EIES24 = 1; // change to Falling edge
      }

      PLA_Pin_TXD_Control(ASSERTED);
      if (TXDStatus() == ASSERTED) // if tx is disabled
      {

        // Disable LD
        // ...

        Clear_TXF_Status(); // clear tx fault flags after tx disable
      }
    }
    else // TX enable
    {

      if (PI2_bit.PI24 == 0) // if tx_disable input is low
      {
        EIES2_bit.EIES24 = 0; // change to rising edge
      }

      PLA_Pin_TXD_Control(DE_ASSERTED);

      if (TXDStatus() == DE_ASSERTED) // if tx is enabled
      {

        // Enable LD
        // ...
      }
    }
  }

  // [DCLEE] 210513 --> LOS PLA ���Ȯ��
  // RX LOS from CDR (GP07)

  if (EIF0_bit.EIF07 == 1) // RX LOS, GP07
  {
    //    I2C_Slave_Buffer_A2[LOWER_MEMORY_A2_READ_CHIP_STATUS] = I2C_Slave_Buffer_A2[LOWER_MEMORY_A2_READ_CHIP_STATUS] + 1;
    EIF0_bit.EIF07 = 0; // clear flag
    //        I2C_Slave_Buffer_A2[LOWER_MEMORY_A2_OPERATION_MODE] = I2C_Slave_Buffer_A2[LOWER_MEMORY_A2_OPERATION_MODE] + 1;
    //        I2C_Slave_Buffer_A2[LOWER_MEMORY_A2_LUT_MODE] = I2C_Slave_Buffer_A2[LOWER_MEMORY_A2_LUT_MODE] + 1;

    if (EIES0_bit.EIES07 == 0) // if the interrupt is generated by rising edge
    {

      //        I2C_Slave_Buffer_A2[LOWER_MEMORY_A2_OPERATION_MODE] = I2C_Slave_Buffer_A2[LOWER_MEMORY_A2_OPERATION_MODE] + 1;
      if (PI0_bit.PI07 == 1) // if RX_LOS_to_MCU input is high
      {
        EIES0_bit.EIES07 = 1; // change to Falling edge
      }

      //      if (PLA_RX_LOS_Status() == DE_ASSERTED)
      {
        // Rx LOS �߻�
        PLA_Soft_RX_LOS_Control_from_CDR(ASSERTED);
      }

      //      if(TXDStatus() == ASSERTED)                                               //if tx is disabled
      //      {
      //
      //        // Disable LD
      //        // ...
      //
      //        Clear_TXF_Status();                                                     //clear tx fault flags after tx disable
      //
      //      }
    }
    else // RX_LOS Clear
    {

      //        I2C_Slave_Buffer_A2[LOWER_MEMORY_A2_LUT_MODE] = I2C_Slave_Buffer_A2[LOWER_MEMORY_A2_LUT_MODE] + 1;
      if (PI0_bit.PI07 == 0) // if RX_LOS_to_MCU input is low
      {
        EIES0_bit.EIES07 = 0; // change to rising edge
      }

      //      if (PLA_RX_LOS_Status() == ASSERTED)
      {
        // Rx LOS �߻�
        PLA_Soft_RX_LOS_Control_from_CDR(DE_ASSERTED);
      }

      //      if(TXDStatus() == DE_ASSERTED)                                            //if tx is enabled
      //      {
      //
      //        // Enable LD
      //        // ...
      //
      //      }
    }
  }
  // [DCLEE] 210513 <-- LOS PLA ���Ȯ��

  // TX Fault from CDR (GP05)

  //  if(EIF0_bit.EIF05 == 1)                                                       //TX disable, GP24
  //  {
  //
  //    EIF0_bit.EIF05 = 0;                                                         //clear flag
  //
  //    if(EIES0_bit.EIES05 == 0)                                                   //if the interrupt is generated by rising edge
  //    {
  //
  //      if(PI0_bit.PI05 == 1)                                                     //if tx_disable input is high
  //      {
  //        EIES0_bit.EIES05 = 1;                                                   //change to Falling edge
  //      }
  //
  ////      if(TXDStatus() == ASSERTED)                                               //if tx is disabled
  ////      {
  ////
  ////        // Disable LD
  ////        // ...
  ////
  ////        Clear_TXF_Status();                                                     //clear tx fault flags after tx disable
  ////
  ////      }
  //
  //    }
  //    else                                                                        //TX enable
  //    {
  //
  //      if(PI0_bit.PI05 == 0)                                                     //if tx_disable input is low
  //      {
  //        EIES0_bit.EIES05 = 0;                                                   //change to rising edge
  //      }
  //
  ////      if(TXDStatus() == DE_ASSERTED)                                            //if tx is enabled
  ////      {
  ////
  ////        // Enable LD
  ////        // ...
  ////
  ////      }
  //    }
  //
  //  }

  // RS1 from HOST (GP15)

  if (EIF1_bit.EIF15 == 1) // RS1 = H
  {

    EIF1_bit.EIF15 = 0; // clear flag

    if (EIES1_bit.EIES15 == 0) // if the interrupt is generated by rising edge
    {

      if (PI1_bit.PI15 == 1) // if RS1 input is high
      {
        EIES1_bit.EIES15 = 1; // change to Falling edge
      }

      //      if(TXDStatus() == ASSERTED)                                               //if tx is disabled
      //      {
      //
      //        // Disable LD
      //        // ...
      //
      //        Clear_TXF_Status();                                                     //clear tx fault flags after tx disable
      //
      //      }
      update_rate_select_operation();
    }
    else // TX enable
    {

      if (PI1_bit.PI15 == 0) // if RS1 input is low
      {
        EIES1_bit.EIES15 = 0; // change to rising edge
      }

      //      if(TXDStatus() == DE_ASSERTED)                                            //if tx is enabled
      //      {
      //
      //        // Enable LD
      //        // ...
      //
      //      }

      update_rate_select_operation();
    }
  }

  // RS0 from HOST (GP13)

  if (EIF1_bit.EIF13 == 1) // RS1 = H
  {

    EIF1_bit.EIF13 = 0; // clear flag

    if (EIES1_bit.EIES13 == 0) // if the interrupt is generated by rising edge
    {

      if (PI1_bit.PI13 == 1) // if RS1 input is high
      {
        EIES1_bit.EIES13 = 1; // change to Falling edge
      }

      //      if(TXDStatus() == ASSERTED)                                               //if tx is disabled
      //      {
      //
      //        // Disable LD
      //        // ...
      //
      //        Clear_TXF_Status();                                                     //clear tx fault flags after tx disable
      //
      //      }
      update_rate_select_operation();
    }
    else // TX enable
    {

      if (PI1_bit.PI13 == 0) // if RS1 input is low
      {
        EIES1_bit.EIES13 = 0; // change to rising edge
      }

      //      if(TXDStatus() == DE_ASSERTED)                                            //if tx is enabled
      //      {
      //
      //        // Enable LD
      //        // ...
      //
      //      }

      update_rate_select_operation();
    }
  }

  IMR = GP_REG1; // restore IMR

#else
#endif

#else

  SW_Delay(2); // delay for tx disable signal stable.

  if (EIF0_bit.EIF07 == 1) // TX disable
  {

    EIF0_bit.EIF07 = 0; // clear flag

    if (EIES0_bit.EIES07 == 0) // if the interrupt is generated by rising edge
    {

      if (PI0_bit.PI07 == 1) // if tx_disable input is high
      {
        EIES0_bit.EIES07 = 1; // change to Falling edge
      }

      if (TXDStatus() == ASSERTED) // if tx is disabled
      {

#ifdef DCDC_BIASING // DCDC Biasing

        DCDC_SEL = DC_DC_CH2;
        VRDCDC = 0; // write 0 to DCDC2 to disable laser

#else // IDAC Biasing

        IDCD1 = 0; // Write 0 to IDAC to disable laser

#endif
        Clear_TXF_Status(); // clear tx fault flags after tx disable
      }
    }
    else // TX enable
    {

      if (PI0_bit.PI07 == 0) // if tx_disable input is low
      {
        EIES0_bit.EIES07 = 0; // change to rising edge
      }

      if (TXDStatus() == DE_ASSERTED) // if tx is enabled
      {

#ifdef DCDC_BIASING // if DCDC biasing

        if (PAGE91H_Memory.PMIC_SELECT & BUCK2_ENABLE) // need re-enable DCDC2 again after TXD de-asserted
        {

          DCDC_SEL = DC_DC_CH2;
          DCCN = DCCNSET; // re-enalbe DCDC2
          APC_Init();     // re-init apc loop
        }
#else               // if IDAC biasing

        if (PAGE91H_Memory.PMIC_SELECT & BUCK1_ENABLE) // if Buck1 is enabled
        {
          APC_Init(); // re-init apc loop
        }
#endif
      }
    }
  }

  IMR = GP_REG1; // restore IMR
#endif
}

//-----------------------------------------------------------------------------
// WATCHDOG_Init function
//   - Initialize watchdog, 131ms
//-----------------------------------------------------------------------------
void WATCHDOG_Init(void)
{

  WDCN_bit.EWDI = 0; // enable interrupt
  WDCN_bit.EWT = 1;  // enable reset on watchdog
  WDCN_bit.WD1 = 1;  //
  WDCN_bit.WD0 = 1;  // 21 count -> 131.072 ms for watchdog interval time
  WDCN_bit.RWT = 1;  // reset watchdog timer
}

//-----------------------------------------------------------------------------
// INRUSH_Init function
//   - disable INRUSH current limitation here
//-----------------------------------------------------------------------------
void INRUSH_Init(void)
{

  INRSH = 0x80; // Disable current limitation(inrush control)
}

//-----------------------------------------------------------------------------
// GPIO function
//   - All GPIOs are initialized here
//-----------------------------------------------------------------------------
void GPIO_Init(void)
{
#if __SFP28_ER__ == 1

#if __SFP28_ER_SEMI_TUNABLE__ == 1

#if __SFP_PLUS_3G_ER_SEMI_TUNABLE__ == 1

#if __SFP_PLUS_3G_ER_SEMI_TUNABLE_HW_VER_2__ == 1

  ////////////////////////////////////////////////////////////////////////////////
  // GPIO - Port 0                                            T-SFP28 (DML/APD), 3G ST-SFP+ (DML/APD)
  ////////////////////////////////////////////////////////////////////////////////
  // Port0.0 => THERMTX,        V_THM ADC0,                   TXDIS_CDR (O): TXDIS_uC
  // Port0.1 => RX_LOS_HOST,    RSSI1 ADC1 (same pin as SR4), V_THM  ADC1
  // Port0.2 => TX_FALUT_HOST,  RSSI2 ADC2 ,                  NC
  // Port0.3 => TX_DIS_XCVR,    RSSI3  ADC3,                  TX_PWR_MON  ADC3
  // Port0.4 => N/A
  // Port0.5 => ADC MD,         MPD3  ADC5,                   TX_FAULT_uC (I), Interrupt ó���ʿ�
  // Port0.6 => ADC VTEC,       MPD0  ADC6,                   APD_FB   ADC6
  // Port0.7 => TX_DIS_HOST,    IntL, open drain, output,     RX_LOS_uC (I),  Interrupt ó���ʿ�
  ////////////////////////////////////////////////////////////////////////////////
  //    IEN0 = 0x80;
  IEN0 |= 0xA0;
  PD0 = 0x01;
  PO0 = 0x01;

  ////////////////////////////////////////////////////////////////////////////////
  // GPIO - Port 1                                             T-SFP28 (DML/APD), 3G ST-SFP+ (DML/APD)
  ////////////////////////////////////////////////////////////////////////////////
  // Port1.0 => MSDA
  // Port1.1 => MSCL
  // Port1.2 => FB2 /CS_3W /SPI_MISO, RSSI0 ADC10,             No Connection
  // Port1.3 => LD_IDAC1/Bias ADC input,      IDAC0,           RS0 input
  // Port1.4 => ADC DCDC_BIAS_ISENSE,         IDAC1,           No Connection
  // Port1.5 => ADC INV_DCDC_FB,              IDAC2,           RS1 input
  // Port1.6 => ADC APD_FB,                   IDAC3,           No Connection
  // Port1.7 => SHEN,                         ModSelL input,   No Connection
  ////////////////////////////////////////////////////////////////////////////////
  IEN1 |= 0x2B;
  PD1 = 0x03;
  PO1 = 0x2B; // weak pullup
              //    PO1_bit.PO13 = 1;
              //    PO1_bit.PO15 = 1;

  //    PO2_bit.PO25 = 0;

  ////////////////////////////////////////////////////////////////////////////////
  // GPIO - Port 2                                              T-SFP28 (DML/APD), 3G ST-SFP+ (DML/APD)
  ////////////////////////////////////////////////////////////////////////////////
  // Port2.0 => SHP0:         ResetL input,                     APD_PWM (APD4)
  // Port2.1 => SHN0:         APD_FB   ADC17,                   RS0_uC (O), No Connection
  // Port2.2 => INV_DCDC_PWM,   LPMode input (same pin as SR4), RX_LOS (O), PLAOUT
  // Port2.3 => APD_PWM,        APD_PWM (APD2),                 TX_FAULT (O), PLAOUT
  // Port2.4 => EA_DS_DAC,      TXDIS output (to TX CDR),       TX_DIS (I), PLAIN,  Interrupt ó���ʿ�
  // Port2.5 => ADC TES_ISENSE, RxLOS Input,                    No Connection, RSTB (to GN1157, O)
  // Port2.6 => VIP2,           MPD1  ADC22,                    RS1_uC  (O), No Connection
  // Port2.7 => SHN1,           MPD2  ADC23,                    RSSI   ADC23
  ////////////////////////////////////////////////////////////////////////////////
  IEN2 |= 0x10;
  PD2 = 0x6E; // 0010 0001
  PO2 = 0x6E; // RSTB (1, Normal), TXDIS (ON, DIS)
  // PO2 |= 0xC0;

#else

  ////////////////////////////////////////////////////////////////////////////////
  // GPIO - Port 0                                            T-SFP28 (DML/APD), 3G ST-SFP+ (DML/APD)
  ////////////////////////////////////////////////////////////////////////////////
  // Port0.0 => THERMTX,        V_THM ADC0,                   TXDIS_CDR (O): TXDIS_uC
  // Port0.1 => RX_LOS_HOST,    RSSI1 ADC1 (same pin as SR4), V_THM  ADC1
  // Port0.2 => TX_FALUT_HOST,  RSSI2 ADC2 ,                  RSSI   ADC2
  // Port0.3 => TX_DIS_XCVR,    RSSI3  ADC3,                  TX_PWR_MON  ADC3
  // Port0.4 => N/A
  // Port0.5 => ADC MD,         MPD3  ADC5,                   TX_FAULT_uC (I), Interrupt ó���ʿ�
  // Port0.6 => ADC VTEC,       MPD0  ADC6,                   APD_FB   ADC6
  // Port0.7 => TX_DIS_HOST,    IntL, open drain, output,     RX_LOS_uC (I),  Interrupt ó���ʿ�
  ////////////////////////////////////////////////////////////////////////////////
  //    IEN0 = 0x80;
  IEN0 |= 0xA0;
  //    PD0 = 0x01;
  //    PO0 = 0x01;
  PD0 = 0x01;
  PO0 = 0xA0;

  ////////////////////////////////////////////////////////////////////////////////
  // GPIO - Port 1                                             T-SFP28 (DML/APD), 3G ST-SFP+ (DML/APD)
  ////////////////////////////////////////////////////////////////////////////////
  // Port1.0 => MSDA
  // Port1.1 => MSCL
  // Port1.2 => FB2 /CS_3W /SPI_MISO, RSSI0 ADC10,             No Connection
  // Port1.3 => LD_IDAC1/Bias ADC input,      IDAC0,           RS0 input
  // Port1.4 => ADC DCDC_BIAS_ISENSE,         IDAC1,           No Connection
  // Port1.5 => ADC INV_DCDC_FB,              IDAC2,           RS1 input
  // Port1.6 => ADC APD_FB,                   IDAC3,           No Connection
  // Port1.7 => SHEN,                         ModSelL input,   No Connection
  ////////////////////////////////////////////////////////////////////////////////
  IEN1 |= 0x4B;
  PD1 = 0x23;
  PO1 = 0x43; // weak pullup

  // IEN1 |= 0x2B;
  //     PD1 = 0x03;
  // //    PO1 = 0x2B; // weak pullup
  //     PO1 = 0x03; // weak pullup

  // PO1_bit.PD16 = 0; // input
  // PO1_bit.PO16 = 1; // pullup
  //    PO1_bit.PO13 = 1;
  //    PO1_bit.PO15 = 1;

  //    PO2_bit.PO25 = 0;

  ////////////////////////////////////////////////////////////////////////////////
  // GPIO - Port 2                                              T-SFP28 (DML/APD), 3G ST-SFP+ (DML/APD)
  ////////////////////////////////////////////////////////////////////////////////
  // Port2.0 => SHP0:         ResetL input,                     APD_PWM (APD4)
  // Port2.1 => SHN0:         APD_FB   ADC17,                   No Connection
  // Port2.2 => INV_DCDC_PWM,   LPMode input (same pin as SR4), RX_LOS (O), PLAOUT
  // Port2.3 => APD_PWM,        APD_PWM (APD2),                 TX_FAULT (O), PLAOUT
  // Port2.4 => EA_DS_DAC,      TXDIS output (to TX CDR),       TX_DIS (I), PLAIN,  Interrupt ó���ʿ�
  // Port2.5 => ADC TES_ISENSE, RxLOS Input,                    No Connection, RSTB (to GN1157, O)
  // Port2.6 => VIP2,           MPD1  ADC22,                    RS1_uC  (O), No Connection
  // Port2.7 => SHN1,           MPD2  ADC23,                    RS0_uC  (O), No Connection
  ////////////////////////////////////////////////////////////////////////////////
  IEN2 |= 0x10;
  PD2 = 0xEC; // 0010 0001
  PO2 = 0xEC; // RSTB (1, Normal), TXDIS (ON, DIS)
  // PO2 |= 0xC0;
#endif

  ////////////////////////////////////////////////////////////////////////////////
  // GPIO - Port 6
  ////////////////////////////////////////////////////////////////////////////////
  // Port6.0 => LX0
  // Port6.1 => LX1
  // Port6.2 => LX2
  // Port6.3 => LX3
  ////////////////////////////////////////////////////////////////////////////////

#else

  ////////////////////////////////////////////////////////////////////////////////
  // GPIO - Port 0                                            T-SFP28 (DML/APD)
  ////////////////////////////////////////////////////////////////////////////////
  // Port0.0 => THERMTX,        V_THM ADC0,                   TXDIS_CDR (O): TXDIS_uC
  // Port0.1 => RX_LOS_HOST,    RSSI1 ADC1 (same pin as SR4), V_THM  ADC1
  // Port0.2 => TX_FALUT_HOST,  RSSI2 ADC2 ,                  RSSI   ADC2
  // Port0.3 => TX_DIS_XCVR,    RSSI3  ADC3,                  TX_PWR_MON  ADC3
  // Port0.4 => N/A
  // Port0.5 => ADC MD,         MPD3  ADC5,                   TX_FAULT_uC (I), Interrupt ó���ʿ�
  // Port0.6 => ADC VTEC,       MPD0  ADC6,                   APD_FB   ADC6
  // Port0.7 => TX_DIS_HOST,    IntL, open drain, output,     RX_LOS_uC (I),  Interrupt ó���ʿ�
  ////////////////////////////////////////////////////////////////////////////////
  //    IEN0 = 0x80;
  IEN0 |= 0xA0;
  PD0 = 0x01;
  PO0 = 0x01;

  ////////////////////////////////////////////////////////////////////////////////
  // GPIO - Port 1                                             T-SFP28 (DML/APD)
  ////////////////////////////////////////////////////////////////////////////////
  // Port1.0 => MSDA
  // Port1.1 => MSCL
  // Port1.2 => FB2 /CS_3W /SPI_MISO, RSSI0 ADC10,             No Connection
  // Port1.3 => LD_IDAC1/Bias ADC input,      IDAC0,           RS0 input
  // Port1.4 => ADC DCDC_BIAS_ISENSE,         IDAC1,           No Connection
  // Port1.5 => ADC INV_DCDC_FB,              IDAC2,           RS1 input
  // Port1.6 => ADC APD_FB,                   IDAC3,           No Connection
  // Port1.7 => SHEN,                         ModSelL input,   No Connection
  ////////////////////////////////////////////////////////////////////////////////
  IEN1 |= 0x2B;
  PD1 = 0x03;
  PO1 = 0x2B; // weak pullup
              //    PO1_bit.PO13 = 1;
              //    PO1_bit.PO15 = 1;

  //    PO2_bit.PO25 = 0;

  ////////////////////////////////////////////////////////////////////////////////
  // GPIO - Port 2                                              T-SFP28 (DML/APD)
  ////////////////////////////////////////////////////////////////////////////////
  // Port2.0 => SHP0:         ResetL input,                     APD_PWM (APD4)
  // Port2.1 => SHN0:         APD_FB   ADC17,                   No Connection
  // Port2.2 => INV_DCDC_PWM,   LPMode input (same pin as SR4), RX_LOS (O), PLAOUT
  // Port2.3 => APD_PWM,        APD_PWM (APD2),                 TX_FAULT (O), PLAOUT
  // Port2.4 => EA_DS_DAC,      TXDIS output (to TX CDR),       TX_DIS (I), PLAIN,  Interrupt ó���ʿ�
  // Port2.5 => ADC TES_ISENSE, RxLOS Input,                    No Connection
  // Port2.6 => VIP2,           MPD1  ADC22,                    RS1_uC  (O)
  // Port2.7 => SHN1,           MPD2  ADC23,                    RS0_uC  (O)
  ////////////////////////////////////////////////////////////////////////////////
  IEN2 |= 0x10;
  PD2 = 0xCC; // 1100 0001
  PO2 = 0xCC; // TXDIS (ON, DIS)
  // PO2 |= 0xC0;

////////////////////////////////////////////////////////////////////////////////
// GPIO - Port 6
////////////////////////////////////////////////////////////////////////////////
// Port6.0 => LX0
// Port6.1 => LX1
// Port6.2 => LX2
// Port6.3 => LX3
////////////////////////////////////////////////////////////////////////////////

// <--
#endif

#else

  ////////////////////////////////////////////////////////////////////////////////
  // GPIO - Port 0
  ////////////////////////////////////////////////////////////////////////////////
  // Port0.0 => THERMTX,        V_THM ADC0,                   NO Connection
  // Port0.1 => RX_LOS_HOST,    RSSI1 ADC1 (same pin as SR4), V_THM  ADC1
  // Port0.2 => TX_FALUT_HOST,  RSSI2 ADC2 ,                  RSSI   ADC2
  // Port0.3 => TX_DIS_XCVR,    RSSI3  ADC3,                  NO Connection
  // Port0.4 => N/A
  // Port0.5 => ADC MD,         MPD3  ADC5,                   TX_PWR_MON  ADC5
  // Port0.6 => ADC VTEC,       MPD0  ADC6,                   APD_FB   ADC6
  // Port0.7 => TX_DIS_HOST,    IntL, open drain, output,     NO Connection
  ////////////////////////////////////////////////////////////////////////////////
  //    IEN0 = 0x80;
  IEN0 = 0x00;
  PD0 = 0x00;
  PO0 = 0x00;

  ////////////////////////////////////////////////////////////////////////////////
  // GPIO - Port 1
  ////////////////////////////////////////////////////////////////////////////////
  // Port1.0 => MSDA
  // Port1.1 => MSCL
  // Port1.2 => FB2 /CS_3W /SPI_MISO, RSSI0 ADC10,             No Connection
  // Port1.3 => LD_IDAC1/Bias ADC input,      IDAC0,           RS0 input
  // Port1.4 => ADC DCDC_BIAS_ISENSE,         IDAC1,           IDAC2
  // Port1.5 => ADC INV_DCDC_FB,              IDAC2,           RS1 input
  // Port1.6 => ADC APD_FB,                   IDAC3,           TX_FAULT output
  // Port1.7 => SHEN,                         ModSelL input,   RX_LOS  output
  ////////////////////////////////////////////////////////////////////////////////
  IEN1 |= 0x2B;
  PD1 = 0xC3;
  PO1 = 0xEB; // weak pullup
              //    PO1_bit.PO13 = 1;
              //    PO1_bit.PO15 = 1;

  //    PO2_bit.PO25 = 0;

  ////////////////////////////////////////////////////////////////////////////////
  // GPIO - Port 2
  ////////////////////////////////////////////////////////////////////////////////
  // Port2.0 => SHP0:         ResetL input,                   TX_DIS input
  // Port2.1 => SHN0:         APD_FB   ADC17,                 TXDIS_CDR output
  // Port2.2 => INV_DCDC_PWM,   LPMode input (same pin as SR4), RX_LOS_uC input
  // Port2.3 => APD_PWM,        APD_PWM (APD2),                 APD_PWM (APD2)
  // Port2.4 => EA_DS_DAC,      TXDIS output (to TX CDR),       EAM_Bias_set (DSDAC4)
  // Port2.5 => ADC TES_ISENSE, RxLOS Input,                    RS1_uC  output
  // Port2.6 => VIP2,           MPD1  ADC22,                    RS0_uC  output
  // Port2.7 => SHN1,           MPD2  ADC23,                    CDR_PWR_EN  output
  ////////////////////////////////////////////////////////////////////////////////
  IEN2 |= 0x05;
  PD2 = 0xE2; // 1100 0001
  PO2 = 0xE2; // TXDIS (ON, DIS)
  // PO2 |= 0xC0;

  ////////////////////////////////////////////////////////////////////////////////
  // GPIO - Port 6
  ////////////////////////////////////////////////////////////////////////////////
  // Port6.0 => LX0
  // Port6.1 => LX1
  // Port6.2 => LX2
  // Port6.3 => LX3
  ////////////////////////////////////////////////////////////////////////////////

#endif

#else

  ////////////////////////////////////////////////////////////////////////////////
  // GPIO - Port 0
  ////////////////////////////////////////////////////////////////////////////////
  // Port0.0 => THERMTX
  // Port0.1 => RX_LOS_HOST
  // Port0.2 => TX_FALUT_HOST
  // Port0.3 => TX_DIS_XCVR
  // Port0.4 => N/A
  // Port0.5 => ADC MD
  // Port0.6 => ADC VTEC
  // Port0.7 => TX_DIS_HOST
  ////////////////////////////////////////////////////////////////////////////////
  IEN0 |= 0x8E;
  PD0 = 0;
  PO0 = 0;
  ////////////////////////////////////////////////////////////////////////////////
  // GPIO - Port 1
  ////////////////////////////////////////////////////////////////////////////////
  // Port1.0 => MSCL
  // Port1.1 => MSDA
  // Port1.2 => FB2 /CS_3W /SPI_MISO
  // Port1.3 => LD_IDAC1/Bias ADC input
  // Port1.4 => ADC DCDC_BIAS_ISENSE
  // Port1.5 => ADC INV_DCDC_FB
  // Port1.6 => ADC APD_FB
  // Port1.7 => SHEN
  ////////////////////////////////////////////////////////////////////////////////
  IEN1 |= 0x83;
  PD1 = 0x03;
  PO1 = 0x03;
  ////////////////////////////////////////////////////////////////////////////////
  // GPIO - Port 2
  ////////////////////////////////////////////////////////////////////////////////
  // Port2.0 => SHP0
  // Port2.1 => SHN0
  // Port2.2 => INV_DCDC_PWM
  // Port2.3 => APD_PWM
  // Port2.4 => EA_DS_DAC
  // Port2.5 => ADC TES_ISENSE
  // Port2.6 => VIP2
  // Port2.7 => SHN1
  ////////////////////////////////////////////////////////////////////////////////
  PD2 |= 0x10; // 1100 0001
  PO2 |= 0x00;
  // PO2 |= 0xC0;
////////////////////////////////////////////////////////////////////////////////
// GPIO - Port 6
////////////////////////////////////////////////////////////////////////////////
// Port6.0 => LX0
// Port6.1 => LX1
// Port6.2 => LX2
// Port6.3 => LX3
////////////////////////////////////////////////////////////////////////////////
#endif
}

//-----------------------------------------------------------------------------
// ADC_Init function
//   - Initialize ADC
//     This function does not disable ADC pin weak pull up. User should disable
//     ADC pin weak pull up before calling this function.
//     ADC calculation for P1, P2, P3
//-----------------------------------------------------------------------------
void ADC_Init(void)
{
#if __SFP28_ER__ == 1

#if __SFP28_ER_SEMI_TUNABLE__ == 1

#if __SFP_PLUS_3G_ER_SEMI_TUNABLE_HW_VER_2__ == 1

  ////////////////////////////////////////////////////////////////////////////////
  // ADC Configuration
  ////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////
  // Priority 1 Configuration
  ////////////////////////////////////////////////////////////////////////////////
  // APD-1 ADC Configuration
  //    ADC_Config(CONFG_EXT_INV, PRIORITY_1, ACQ_EXT_1_0us, ADC_AVG_001SMP, ADC_BI_POLAR);
  //    ADC_Channel_Config(CONFG_EXT_INV,GND_REF, INVFB);                           //Select the ADC Channel

  // APD-2 ADC Configuration
  ADC_Config(CONFG_EXT_BOOST1, PRIORITY_1, ACQ_EXT_1_0us, ADC_AVG_001SMP, ADC_UNI_POLAR);
  ADC_Channel_Config(CONFG_EXT_BOOST1, APD_FB_GP06_ADC6, GND_REF); // Select the ADC Channel

  // TEC1-VTHERM
  ADC_Config(CONFG_VTHERM1, PRIORITY_1, ACQ_EXT_1_0us, ADC_AVG_008SMP, ADC_UNI_POLAR);
  //    ADC_Config(CONFG_VTHERM1, PRIORITY_1, ACQ_EXT_1_0us, ADC_AVG_002SMP, ADC_UNI_POLAR);
  ADC_Channel_Config(CONFG_VTHERM1, V_THM_ADC1, GND_REF); // Select the ADC Channel

  //    ADC_Config(CONFG_VTHERM2, PRIORITY_1, ACQ_EXT_1_0us, ADC_AVG_008SMP, ADC_UNI_POLAR);
  //    ADC_Channel_Config(CONFG_VTHERM2, V_THM_ADC0, GND_REF);                   //Select the ADC Channel

  ////////////////////////////////////////////////////////////////////////////////
  // Priority 2 Configuration
  ////////////////////////////////////////////////////////////////////////////////
  // RSSI ADC Configuration
  ADC_Config(CONFG_RSSI, PRIORITY_2, ACQ_EXT_2_0us, ADC_AVG_016SMP, ADC_UNI_POLAR);
  ADC_Channel_Config(CONFG_RSSI, RSSI_GP27_ADC23, GND_REF); // Select the ADC Channel

  // TX_PWR_NON ADC Configuration
  ADC_Config(CONFG_TX_PWR_NON, PRIORITY_2, ACQ_EXT_2_0us, ADC_AVG_016SMP, ADC_UNI_POLAR);
  ADC_Channel_Config(CONFG_TX_PWR_NON, TX_PWR_MON_GP03_ADC3, GND_REF); // Select the ADC Channel

  // VCC Measurement
  ADC_Config(CONFG_VCC_COMP, PRIORITY_2, ACQ_EXT_2_0us, ADC_AVG_016SMP, ADC_UNI_POLAR);
  ADC_Channel_Config(CONFG_VCC_COMP, VCC_DIV, GND_REF); // Select the ADC Channel

  // TEC Current ADC Configuration
  //    ADC_Config(CONFG_TECC, PRIORITY_3, ACQ_EXT_2_0us, ADC_AVG_128SMP, ADC_BI_POLAR);
  //    ADC_Channel_Config(CONFG_TECC, VCC_DIV /* TEC_ISENSE */, LX2);                            //Select the ADC Channel
  //
  // Temperature Sensor Configuration and Averaging Configuration
  TEMPCN_bit.ETEMP = 0; // no external temperature sensor in this evk
  TEMPCN_bit.TEMP_AVG = 6;
  TEMPCN_bit.TEMP_ACQ = 2; // It is recommended to use at least 0.5us of extended acquisition for S/H channels to improve the S/H performance.

  ADST = ADST_SET;
  ADCN = ADCN_SET;      // enable ADC
  TEMPCN_bit.ITEMP = 1; // enable internal temperature sensor

#else

  ////////////////////////////////////////////////////////////////////////////////
  // ADC Configuration
  ////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////
  // Priority 1 Configuration
  ////////////////////////////////////////////////////////////////////////////////
  // APD-1 ADC Configuration
  //    ADC_Config(CONFG_EXT_INV, PRIORITY_1, ACQ_EXT_1_0us, ADC_AVG_001SMP, ADC_BI_POLAR);
  //    ADC_Channel_Config(CONFG_EXT_INV,GND_REF, INVFB);                           //Select the ADC Channel

  // APD-2 ADC Configuration
  ADC_Config(CONFG_EXT_BOOST1, PRIORITY_1, ACQ_EXT_1_0us, ADC_AVG_001SMP, ADC_UNI_POLAR);
  ADC_Channel_Config(CONFG_EXT_BOOST1, APD_FB_GP06_ADC6, GND_REF); // Select the ADC Channel

  // TEC1-VTHERM
  ADC_Config(CONFG_VTHERM1, PRIORITY_1, ACQ_EXT_1_0us, ADC_AVG_008SMP, ADC_UNI_POLAR);
  //    ADC_Config(CONFG_VTHERM1, PRIORITY_1, ACQ_EXT_1_0us, ADC_AVG_002SMP, ADC_UNI_POLAR);
  ADC_Channel_Config(CONFG_VTHERM1, V_THM_ADC1, GND_REF); // Select the ADC Channel

  //    ADC_Config(CONFG_VTHERM2, PRIORITY_1, ACQ_EXT_1_0us, ADC_AVG_008SMP, ADC_UNI_POLAR);
  //    ADC_Channel_Config(CONFG_VTHERM2, V_THM_ADC0, GND_REF);                   //Select the ADC Channel

  ////////////////////////////////////////////////////////////////////////////////
  // Priority 2 Configuration
  ////////////////////////////////////////////////////////////////////////////////
  // RSSI ADC Configuration
  ADC_Config(CONFG_RSSI, PRIORITY_2, ACQ_EXT_2_0us, ADC_AVG_016SMP, ADC_UNI_POLAR);
  ADC_Channel_Config(CONFG_RSSI, RSSI_GP02_ADC2, GND_REF); // Select the ADC Channel

  // TX_PWR_NON ADC Configuration
  ADC_Config(CONFG_TX_PWR_NON, PRIORITY_2, ACQ_EXT_2_0us, ADC_AVG_016SMP, ADC_UNI_POLAR);
  ADC_Channel_Config(CONFG_TX_PWR_NON, TX_PWR_MON_GP03_ADC3, GND_REF); // Select the ADC Channel

  // VCC Measurement
  ADC_Config(CONFG_VCC_COMP, PRIORITY_2, ACQ_EXT_2_0us, ADC_AVG_016SMP, ADC_UNI_POLAR);
  ADC_Channel_Config(CONFG_VCC_COMP, VCC_DIV, GND_REF); // Select the ADC Channel

  // TEC Current ADC Configuration
  //    ADC_Config(CONFG_TECC, PRIORITY_3, ACQ_EXT_2_0us, ADC_AVG_128SMP, ADC_BI_POLAR);
  //    ADC_Channel_Config(CONFG_TECC, VCC_DIV /* TEC_ISENSE */, LX2);                            //Select the ADC Channel
  //
  // Temperature Sensor Configuration and Averaging Configuration
  TEMPCN_bit.ETEMP = 0; // no external temperature sensor in this evk
  TEMPCN_bit.TEMP_AVG = 6;
  TEMPCN_bit.TEMP_ACQ = 2; // It is recommended to use at least 0.5us of extended acquisition for S/H channels to improve the S/H performance.

  ADST = ADST_SET;
  ADCN = ADCN_SET;      // enable ADC
  TEMPCN_bit.ITEMP = 1; // enable internal temperature sensor

#endif

#else

  ////////////////////////////////////////////////////////////////////////////////
  // ADC Configuration
  ////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////
  // Priority 1 Configuration
  ////////////////////////////////////////////////////////////////////////////////
  // APD-1 ADC Configuration
  //    ADC_Config(CONFG_EXT_INV, PRIORITY_1, ACQ_EXT_1_0us, ADC_AVG_001SMP, ADC_BI_POLAR);
  //    ADC_Channel_Config(CONFG_EXT_INV,GND_REF, INVFB);                           //Select the ADC Channel

  // APD-2 ADC Configuration
  ADC_Config(CONFG_EXT_BOOST1, PRIORITY_1, ACQ_EXT_1_0us, ADC_AVG_001SMP, ADC_UNI_POLAR);
  ADC_Channel_Config(CONFG_EXT_BOOST1, APD_FB_GP06_ADC6, GND_REF); // Select the ADC Channel

  // TEC1-VTHERM
  ADC_Config(CONFG_VTHERM1, PRIORITY_1, ACQ_EXT_1_0us, ADC_AVG_008SMP, ADC_UNI_POLAR);
  //    ADC_Config(CONFG_VTHERM1, PRIORITY_1, ACQ_EXT_1_0us, ADC_AVG_002SMP, ADC_UNI_POLAR);
  ADC_Channel_Config(CONFG_VTHERM1, V_THM_ADC1, GND_REF); // Select the ADC Channel

  //    ADC_Config(CONFG_VTHERM2, PRIORITY_1, ACQ_EXT_1_0us, ADC_AVG_008SMP, ADC_UNI_POLAR);
  //    ADC_Channel_Config(CONFG_VTHERM2, V_THM_ADC0, GND_REF);                   //Select the ADC Channel

  ////////////////////////////////////////////////////////////////////////////////
  // Priority 2 Configuration
  ////////////////////////////////////////////////////////////////////////////////
  // RSSI ADC Configuration
  ADC_Config(CONFG_RSSI, PRIORITY_2, ACQ_EXT_2_0us, ADC_AVG_016SMP, ADC_UNI_POLAR);
  ADC_Channel_Config(CONFG_RSSI, RSSI_GP02_ADC2, GND_REF); // Select the ADC Channel

  // TX_PWR_NON ADC Configuration
  ADC_Config(CONFG_TX_PWR_NON, PRIORITY_2, ACQ_EXT_2_0us, ADC_AVG_016SMP, ADC_UNI_POLAR);
  ADC_Channel_Config(CONFG_TX_PWR_NON, TX_PWR_MON_GP05_ADC5, GND_REF); // Select the ADC Channel

  // VCC Measurement
  ADC_Config(CONFG_VCC_COMP, PRIORITY_2, ACQ_EXT_2_0us, ADC_AVG_016SMP, ADC_UNI_POLAR);
  ADC_Channel_Config(CONFG_VCC_COMP, VCC_DIV, GND_REF); // Select the ADC Channel

  // TEC Current ADC Configuration
  //    ADC_Config(CONFG_TECC, PRIORITY_3, ACQ_EXT_2_0us, ADC_AVG_128SMP, ADC_BI_POLAR);
  //    ADC_Channel_Config(CONFG_TECC, VCC_DIV /* TEC_ISENSE */, LX2);                            //Select the ADC Channel
  //
  // Temperature Sensor Configuration and Averaging Configuration
  TEMPCN_bit.ETEMP = 0; // no external temperature sensor in this evk
  TEMPCN_bit.TEMP_AVG = 6;
  TEMPCN_bit.TEMP_ACQ = 2; // It is recommended to use at least 0.5us of extended acquisition for S/H channels to improve the S/H performance.

  ADST = ADST_SET;
  ADCN = ADCN_SET;      // enable ADC
  TEMPCN_bit.ITEMP = 1; // enable internal temperature sensor

#endif

#else

  ////////////////////////////////////////////////////////////////////////////////
  // ADC Configuration
  ////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////
  // Priority 1 Configuration
  ////////////////////////////////////////////////////////////////////////////////
  // APD-1 ADC Configuration
  ADC_Config(CONFG_EXT_INV, PRIORITY_1, ACQ_EXT_1_0us, ADC_AVG_001SMP, ADC_BI_POLAR);
  ADC_Channel_Config(CONFG_EXT_INV, GND_REF, INVFB); // Select the ADC Channel

  // APD-2 ADC Configuration
  ADC_Config(CONFG_EXT_BOOST1, PRIORITY_1, ACQ_EXT_1_0us, ADC_AVG_001SMP, ADC_UNI_POLAR);
  ADC_Channel_Config(CONFG_EXT_BOOST1, APDFB, GND_REF); // Select the ADC Channel

  // TEC2-VTHERM
  ADC_Config(CONFG_VTHERM2, PRIORITY_1, ACQ_EXT_1_0us, ADC_AVG_008SMP, ADC_UNI_POLAR);
  ADC_Channel_Config(CONFG_VTHERM2, VTHERM2_GP00, GND_REF); // Select the ADC Channel

  ////////////////////////////////////////////////////////////////////////////////
  // Priority 2 Configuration
  ////////////////////////////////////////////////////////////////////////////////

  // VTEC ADC Configuration
  ADC_Config(CONFG_VTEC, PRIORITY_2, ACQ_EXT_2_0us, ADC_AVG_016SMP, ADC_BI_POLAR);
  ADC_Channel_Config(CONFG_VTEC, VTEC, TEC_ISENSE); // Select the ADC Channel

  // MD ADC Configuration
  ADC_Config(CONFG_APC1, PRIORITY_2, ACQ_EXT_2_0us, ADC_AVG_016SMP, ADC_UNI_POLAR);
  ADC_Channel_Config(CONFG_APC1, VCCO, MD); // Select the ADC Channel

  // VCC Measurement
  ADC_Config(CONFG_VCC_COMP, PRIORITY_2, ACQ_EXT_2_0us, ADC_AVG_016SMP, ADC_UNI_POLAR);
  ADC_Channel_Config(CONFG_VCC_COMP, VCC_DIV, GND_REF); // Select the ADC Channel

  ////////////////////////////////////////////////////////////////////////////////
  // Priority 3 Configuration
  ////////////////////////////////////////////////////////////////////////////////

  // DC-DC ADC FB1 Configuration
  ADC_Config(CONFG_DC_DCFB1, PRIORITY_3, ACQ_EXT_2_0us, ADC_AVG_128SMP, ADC_UNI_POLAR);
  ADC_Channel_Config(CONFG_DC_DCFB1, DC_DC_FB1, GND_REF); // Select the ADC Channel

  // DC-DC ADC FB2 Configuration
  ADC_Config(CONFG_DC_DCFB2, PRIORITY_3, ACQ_EXT_2_0us, ADC_AVG_128SMP, ADC_UNI_POLAR);
  ADC_Channel_Config(CONFG_DC_DCFB2, DC_DC_FB2, GND_REF); // Select the ADC Channel

  // TEC Current ADC Configuration
  ADC_Config(CONFG_TECC, PRIORITY_3, ACQ_EXT_2_0us, ADC_AVG_128SMP, ADC_BI_POLAR);
  ADC_Channel_Config(CONFG_TECC, TEC_ISENSE, LX4); // Select the ADC Channel

  // ADC offset Configuration
  ADC_Config(CONFG_ADC_OFFSET, PRIORITY_3, ACQ_EXT_2_0us, ADC_AVG_128SMP, ADC_BI_POLAR);
  ADC_Channel_Config(CONFG_ADC_OFFSET, GND_REF, GND_REF); // Select the ADC Channel

#ifdef DCDC_BIASING

  // Bias Measurement
  ADC_Config(CONFG_BIAS, PRIORITY_3, ACQ_EXT_2_0us, ADC_AVG_128SMP, ADC_UNI_POLAR);
  ADC_Channel_Config(CONFG_BIAS, DC_DC_BIAS_ISENSE, BIAS_FB); // Select the ADC Channel

#endif

  // Temperature Sensor Configuration and Averaging Configuration
  TEMPCN_bit.ETEMP = 0; // no external temperature sensor in this evk
  TEMPCN_bit.TEMP_AVG = 6;
  TEMPCN_bit.TEMP_ACQ = 2; // It is recommended to use at least 0.5us of extended acquisition for S/H channels to improve the S/H performance.

  ADST = ADST_SET;
  ADCN = ADCN_SET;      // enable ADC
  TEMPCN_bit.ITEMP = 1; // enable internal temperature sensor
#endif
}

//-----------------------------------------------------------------------------
// TXD_External_Interrupt_init function
//   - initialize external interrupt for txd
//-----------------------------------------------------------------------------
void TXD_External_Interrupt_init(void)
{
#if __SFP28_ER__ == 1

#if __SFP28_ER_SEMI_TUNABLE__ == 1

  // GP24: TXDIS
  EIF2_bit.EIF24 = 0; // clear flag

  if (PI2_bit.PI24 == 0) // check the external TXD input
  {
    EIES2_bit.EIES24 = 0; // Trigger at rising edge
  }
  else
  {
    EIES2_bit.EIES24 = 1; // Trigger at falling edge
  }
  EIE2_bit.EIE24 = 1; // enable external interrupt

  //    // GP05: TX_FAULT_uC
  //    EIF0_bit.EIF05   = 0;                                                       //clear flag
  //
  //    if(PI0_bit.PI05 == 0)                                                       //check the external TXD input
  //    {
  //      EIES0_bit.EIES05 = 0;                                                     //Trigger at rising edge
  //    }
  //    else
  //    {
  //      EIES0_bit.EIES05 = 1;                                                     //Trigger at falling edge
  //    }
  //    EIE0_bit.EIE05   = 1;                                                       //enable external interrupt
  //

  // [DCLEE] 210513 --> LOS PLA ���Ȯ��

  // GP07: RX_LOS_uC
  EIF0_bit.EIF07 = 0; // clear flag

  if (PI0_bit.PI07 == 0) // check the external TXD input
  {
    EIES0_bit.EIES07 = 0; // Trigger at rising edge
  }
  else
  {
    EIES0_bit.EIES07 = 1; // Trigger at falling edge
  }
  EIE0_bit.EIE07 = 1; // enable external interrupt
  // [DCLEE] 210513 <-- LOS PLA ���Ȯ��

  // GP15: RS1
  EIF1_bit.EIF15 = 0; // clear flag

  if (PI1_bit.PI15 == 0) // check the external RS1 input
  {
    EIES1_bit.EIES15 = 0; // Trigger at rising edge
  }
  else
  {
    EIES1_bit.EIES15 = 1; // Trigger at falling edge
  }
  EIE1_bit.EIE15 = 1; // enable external interrupt

  // GP13: RS0
  EIF1_bit.EIF13 = 0; // clear flag

  if (PI1_bit.PI13 == 0) // check the external RS0 input
  {
    EIES1_bit.EIES13 = 0; // Trigger at rising edge
  }
  else
  {
    EIES1_bit.EIES13 = 1; // Trigger at falling edge
  }
  EIE1_bit.EIE13 = 1; // enable external interrupt

#else

  EIF1_bit.EIF17 = 0; // clear flag

  if (PI1_bit.PI17 == 0) // check the external TXD input
  {
    EIES1_bit.EIES17 = 0; // Trigger at rising edge
  }
  else
  {
    EIES1_bit.EIES17 = 1; // Trigger at falling edge
  }
  EIE1_bit.EIE17 = 1; // enable external interrupt

#endif

#else

  EIF0_bit.EIF07 = 0; // clear flag

  if (PI0_bit.PI07 == 0) // check the external TXD input
  {
    EIES0_bit.EIES07 = 0; // Trigger at rising edge
  }
  else
  {
    EIES0_bit.EIES07 = 1; // Trigger at falling edge
  }
  EIE0_bit.EIE07 = 1; // enable external interrupt
#endif
}

//-----------------------------------------------------------------------------
// Buck_Init function
//   - Initialize Buck
//     This function enables one of DC-DC buck and sets the unTarget voltage.
//     Input: Channel: Valid value DC_DC_CH1,DC_DC_CH2 and DC_DC_CH3
//     Target: 16-bit value wrt 6.55V full scale.
//-----------------------------------------------------------------------------
void Buck_Init(unsigned int unChannel, unsigned int unTarget)
{
#if __SFP28_ER__ == 1
#else
  unsigned int unPI_Enable = __swap_bytes(PAGE91H_Memory.BUCK_PI_CTRL); // get the dcdc control setting

  if (unChannel <= DC_DC_CH3) // check the dcdc channel, in this evk board we only support DCDC1 and DCDC2
  {
    DCDC_SEL = unChannel; // Select One of DCDC

    if (DCCN != DCCNSET) // check the DCDC control configuration has been set or not
    {
      // Set the time constants for the MOS devices
      NMOS_ON_ST = __swap_bytes(PAGE91H_Memory.BUCK_NMOS_ON_STARTUP);
      NMOS_ON = __swap_bytes(PAGE91H_Memory.BUCK_NMOS_ON);
      PMOS_ON_ST = __swap_bytes(PAGE91H_Memory.BUCK_PMOS_ON_STARTUP);
      PMOS_ON = __swap_bytes(PAGE91H_Memory.BUCK_PMOS_ON);
      IZ_DAC = __swap_bytes(PAGE91H_Memory.BUCK_IZDAC);
      DCDC_OPT = __swap_bytes(PAGE91H_Memory.BUCK_DC_DC_OPTIONS);

#ifdef DCDC_BIASING // DCDC Biasing

      if (DC_DC_CH2 == DCDC_SEL) // if DCDC biasing, DCDC2 supports TXD_EN function, that means if PLA1 is asserted, it will shutdown DCDC2.
      {
        DCDC_OPT = 0x0230; // enable TXD_EN
      }

#endif
      // Set PI configuration
      PI_Config(PI_INDEX_KP, __swap_bytes(PAGE91H_Memory.BUCK_OUTERLOOPKP));
      PI_Config(PI_INDEX_KI, __swap_bytes(PAGE91H_Memory.BUCK_OUTERLOOPKI));
      PI_Config(PI_INDEX_SHIFT, __swap_bytes(PAGE91H_Memory.BUCK_OUTLOOPSHIFT));
      PI_Config(PI_INDEX_OP_CLAMP, __swap_bytes(PAGE91H_Memory.BUCK_OUTLOOPPOSTCLAMP));

      if (unPI_Enable & 0x8000) // if DCDC is in PI mode
      {
        PI_Config(PI_INDEX_SETPOINT, CalcPIBuckTarget(unTarget)); // set teh target
        PICNT = unPI_Enable;                                      // Digital control enable

        DCCN = DCCNSET;
      }
      else
      {
        unTarget = CalcBuckTarget(unTarget); // Convert the input value into Buck unTarget

        if (unTarget < START_BUCK) // calculate teh start setting for DCDC
        {
          VRDCDC = unTarget;
        }
        else
        {
          VRDCDC = START_BUCK;
        }

        DCCN = DCCNSET; // DC-DC Enable

        SW_Delay(2000); // Delay to allow startup

        if (unTarget > START_BUCK)
        {
          // Imnportant Note:
          // The DC-DC ramp should allow to startup DC for >200mA startup load for various DC_DC target output
          RampDCDCBuck(unTarget);
        }
      }
    }
  }
#endif
}

//-----------------------------------------------------------------------------
// DCDC_Init function
//   - Initialize Buck converter
//-----------------------------------------------------------------------------
void DCDC_Init(void)
{
#if __SFP28_ER__ == 1
#else
  unsigned int unTarget = 0;

  if (PAGE91H_Memory.PMIC_SELECT & BUCK1_ENABLE) // check if the BUCK1 is enabled
  {

    unTarget = __swap_bytes(PAGE91H_Memory.BUCK_DC_DC1_TARGET); // calculate the set point

    if (unTarget > __swap_bytes(PAGE91H_Memory.BUCK_MAX_DCDC1))
    {
      unTarget = __swap_bytes(PAGE91H_Memory.BUCK_MAX_DCDC1);
    }

    Buck_Init(DC_DC_CH1, unTarget); // init DCDC1
  }
  else
  {
    DCDC_SEL = DC_DC_CH1; // Select One of DCDC
    DCCN &= ~0x0200;      // disable DCDC
    PICNT = 0;
  }

  if (PAGE91H_Memory.PMIC_SELECT & BUCK2_ENABLE) // check if the BUCK2 is enabled
  {

#ifdef DCDC_BIASING

    Buck_Init(DC_DC_CH2, 0);

#else

    unTarget = __swap_bytes(PAGE91H_Memory.BUCK_DC_DC2_TARGET); // if in IDAC biasing mode, the DCDC is set to supply VLD(2.5V)

    if (unTarget > __swap_bytes(PAGE91H_Memory.BUCK_MAX_DCDC2))
    {
      unTarget = __swap_bytes(PAGE91H_Memory.BUCK_MAX_DCDC2);
    }

    Buck_Init(DC_DC_CH2, unTarget);

#endif
  }
  else
  {
    DCDC_SEL = DC_DC_CH2; // Select One of DCDC
    DCCN &= ~0x0200;
    PICNT = 0;
  }
#endif
}

//-----------------------------------------------------------------------------
// TECC_Init function
//   - Initialize TEC2
//-----------------------------------------------------------------------------
void TECC_Init(unsigned int unChannel)
{
#if __SFP28_ER__ == 1
  //  signed int  unVal;
  A2_PAGE_81H_MEMORY_MAP *flashPtr;
  //  A2_PAGE_80H_MEMORY_MAP * flashPtr1

  flashPtr = (A2_PAGE_81H_MEMORY_MAP *)&I2C_Slave_Buffer_A2_P81H_Up[0];

  if (unChannel == TEC_CH1)
  {
    if ((flashPtr->PMIC_SELECT & TEC1_ENABLE) == TEC1_ENABLE) // if TEC is enabled?
    {
      {

        ConfigTec1(INDEX_TEC_SETPOINT, __swap_bytes(flashPtr->TEC1_SETPOINT));
        ConfigTec1(INDEX_TEC_Kp, __swap_bytes(flashPtr->TEC1_KP));
        ConfigTec1(INDEX_TEC_Ki, __swap_bytes(flashPtr->TEC1_KI));
        ConfigTec1(INDEX_TEC_Kd, __swap_bytes(flashPtr->TEC1_KD));
        ConfigTec1(INDEX_TEC_SHIFT, __swap_bytes(flashPtr->TEC1_SHIFT));
        ConfigTec1(INDEX_TEC_POS_ERR_CP, __swap_bytes(flashPtr->TEC1_POSERRCLAMP));
        ConfigTec1(INDEX_TEC_NEG_ERR_CP, __swap_bytes(flashPtr->TEC1_NEGERRCLAMP));
        ConfigTec1(INDEX_TEC_POS_OP_CP, __swap_bytes(flashPtr->TEC1_POSOPCLAMP));
        ConfigTec1(INDEX_TEC_NEG_OP_CP, __swap_bytes(flashPtr->TEC1_NEGOPCLAMP));

        ConfigTec1(INDEX_TEC_CURR_CONFIG, __swap_bytes(flashPtr->TEC1_CNFGCURRENTMEA_BURSTGPIOCONFIG));
        ConfigTec1(INDEX_TEC_OFFSET_TRIG, __swap_bytes(flashPtr->TEC1_OFFSETRIGGER));
        ConfigTec1(INDEX_TEC_DUTY_OFFSET, __swap_bytes(flashPtr->TEC1_BURSTPWMDUTYOFFSET));

        TECCN1 = TEC_CONTROL_REG; // configure TEC control
      }
    }
    else
    {

      TECCN1 = 0; // Disable TEC Channel 2
    }
  }
  NORMV = __swap_bytes(flashPtr->TEC1_NORMAL_VCC); // set normal VCC for TEC2

#else

#endif
}

void APD_Init(void)
{
#if __SFP28_ER__ == 1

#if __SFP28_ER_SEMI_TUNABLE__ == 1

#if __SFP_PLUS_3G_ER_SEMI_TUNABLE__ == 1
  // GN_1157
#if __HSFP_10G_ER_SEMI_TUNABLE__ == 1

  unsigned int unData = 0;
  A2_PAGE_81H_MEMORY_MAP *flashPtr;
  //  A2_PAGE_80H_MEMORY_MAP * flashPtr1

  flashPtr = (A2_PAGE_81H_MEMORY_MAP *)&I2C_Slave_Buffer_A2_P81H_Up[0];

  MIS1 = 0;

  //  if( PAGE91H_Memory.PMIC_SELECT & APD_ENABLE )
  if ((flashPtr->PMIC_SELECT & APD_ENABLE) == APD_ENABLE) // if TEC is enabled?
  {
    if (~(APDCN4 & 0x0040))
    {
      // APD
      //      flashPtr->APD_ERRSTARTCLAMP = __swap_bytes(0x007F); // (127)
      //      flashPtr->APD_DUTYCLAMP = __swap_bytes(0xB300); // (45824)
      //      //        flashPtr->APD_INTEGRALGAIN = __swap_bytes(0x0800); //
      //      flashPtr->APD_INTEGRALGAIN = __swap_bytes(0x0001); // (1)
      //      flashPtr->APD_DUTYSTARTINCCLAMP = __swap_bytes(0x0040); // (64)
      //      flashPtr->APD_INTEGRALCLAMP = __swap_bytes(0xFFF7); // (65527)
      //      flashPtr->APD_APDNEGERRCLAMP = __swap_bytes(0x0020); // (32)
      //      flashPtr->APD_APDPOSERRCLAMP = __swap_bytes(0x0020); // (32)
      //      flashPtr->APD_PROPORTIONALGAIN = __swap_bytes(0xF000); // (61440)

      // Configure APD
      APDIDX4 = IDX_ERRP_START_CLAMP; // Error Start Clamp
      //      APDDAT4 = __swap_bytes(flashPtr->APD_ERRSTARTCLAMP);
      APDDAT4 = (0x007F);

      APDIDX4 = IDX_DUTY_CLAMP; // Duty Clamp
      //      APDDAT4 = __swap_bytes(flashPtr->APD_DUTYCLAMP);
      APDDAT4 = (0xB300);

      APDIDX4 = IDX_INTEGAL_GAIN; // Integral gain
      //      APDDAT4 = __swap_bytes(flashPtr->APD_INTEGRALGAIN);
      APDDAT4 = (0x0001);

      APDIDX4 = IDX_START_DUTY_CLAMP; // Duty Start Clamp
      //      APDDAT4 = __swap_bytes(flashPtr->APD_DUTYSTARTINCCLAMP);
      APDDAT4 = (0x0040);

      APDIDX4 = IDX_CLAMP_INTEGAL; // Integral Clamp
      //      APDDAT4 = __swap_bytes(flashPtr->APD_INTEGRALCLAMP);
      APDDAT4 = (0xFFF7);

      APDIDX4 = IDX_ERRN_CLAMP; // Error Negative Clamp
      //      APDDAT4 = __swap_bytes(flashPtr->APD_APDNEGERRCLAMP);
      APDDAT4 = (0x0020);

      APDIDX4 = IDX_ERRP_CLAMP; // Error Positive Clamp
      //      APDDAT4 = __swap_bytes(flashPtr->APD_APDPOSERRCLAMP);;
      APDDAT4 = (0x0020);

      APDIDX4 = IDX_PROP_GAIN; // Proportional Gain
      //      APDDAT4 = __swap_bytes(flashPtr->APD_PROPORTIONALGAIN);
      APDDAT4 = (0xF000);

      if (flashPtr->APD_TARGET_OUTPUT > 500)
      {
        unData = CalcExternalBoostTarget(500);
        APDIDX4 = IDX_TARGET; // Target Voltage
        APDDAT4 = unData;
        //        flashPtr->APD_CURRENT_SETTING = __swap_bytes(flashPtr->APD_TARGET_OUTPUT);
        flashPtr->APD_CURRENT_SETTING = __swap_bytes(unData);

        APDCN4 = __swap_bytes(flashPtr->APD_CONFIG); // Configure APD setting

        SW_Delay(1000);

        unData = CalcExternalBoostTarget(__swap_bytes(flashPtr->APD_TARGET_OUTPUT));
        APDIDX4 = IDX_TARGET; // Target Voltage
        APDDAT4 = unData;
        //        flashPtr->APD_CURRENT_SETTING = __swap_bytes(flashPtr->APD_TARGET_OUTPUT);
        flashPtr->APD_CURRENT_SETTING = __swap_bytes(unData);

        //        APDCN2 =  __swap_bytes(flashPtr->APD_CONFIG);                        //Configure APD setting
      }
      else
      {
        unData = CalcExternalBoostTarget(__swap_bytes(flashPtr->APD_TARGET_OUTPUT));
        APDIDX4 = IDX_TARGET; // Target Voltage
        APDDAT4 = unData;
        //        flashPtr->APD_CURRENT_SETTING = __swap_bytes(flashPtr->APD_TARGET_OUTPUT);
        flashPtr->APD_CURRENT_SETTING = __swap_bytes(unData);

        APDCN4 = __swap_bytes(flashPtr->APD_CONFIG); // Configure APD setting
      }

      APDIDX4 = IDX_DUTY;                          // Duty Cycle
      APDCN4 = __swap_bytes(flashPtr->APD_CONFIG); // Configure APD setting
    }
  }
  else
  {
    APDIDX4 = IDX_DUTY; // Duty Cycle
    APDCN4 = 0;         // disable APD
  }

#endif

#else

  unsigned int unData = 0;
  A2_PAGE_81H_MEMORY_MAP *flashPtr;
  //  A2_PAGE_80H_MEMORY_MAP * flashPtr1

  flashPtr = (A2_PAGE_81H_MEMORY_MAP *)&I2C_Slave_Buffer_A2_P81H_Up[0];

  MIS1 = 0;

  //  if( PAGE91H_Memory.PMIC_SELECT & APD_ENABLE )
  if ((flashPtr->PMIC_SELECT & APD_ENABLE) == APD_ENABLE) // if TEC is enabled?
  {
    if (~(APDCN4 & 0x0040))
    {
      // Configure APD
      APDIDX4 = IDX_ERRP_START_CLAMP; // Error Start Clamp
      APDDAT4 = __swap_bytes(flashPtr->APD_ERRSTARTCLAMP);

      APDIDX4 = IDX_DUTY_CLAMP; // Duty Clamp
      APDDAT4 = __swap_bytes(flashPtr->APD_DUTYCLAMP);

      APDIDX4 = IDX_INTEGAL_GAIN; // Integral gain
      APDDAT4 = __swap_bytes(flashPtr->APD_INTEGRALGAIN);

      APDIDX4 = IDX_START_DUTY_CLAMP; // Duty Start Clamp
      APDDAT4 = __swap_bytes(flashPtr->APD_DUTYSTARTINCCLAMP);

      APDIDX4 = IDX_CLAMP_INTEGAL; // Integral Clamp
      APDDAT4 = __swap_bytes(flashPtr->APD_INTEGRALCLAMP);

      APDIDX4 = IDX_ERRN_CLAMP; // Error Negative Clamp
      APDDAT4 = __swap_bytes(flashPtr->APD_APDNEGERRCLAMP);

      APDIDX4 = IDX_ERRP_CLAMP; // Error Positive Clamp
      APDDAT4 = __swap_bytes(flashPtr->APD_APDPOSERRCLAMP);

      APDIDX4 = IDX_PROP_GAIN; // Proportional Gain
      APDDAT4 = __swap_bytes(flashPtr->APD_PROPORTIONALGAIN);

      if (flashPtr->APD_TARGET_OUTPUT > 500)
      {
        unData = CalcExternalBoostTarget(500);
        APDIDX4 = IDX_TARGET; // Target Voltage
        APDDAT4 = unData;
        //        flashPtr->APD_CURRENT_SETTING = __swap_bytes(flashPtr->APD_TARGET_OUTPUT);
        flashPtr->APD_CURRENT_SETTING = __swap_bytes(unData);

        APDCN4 = __swap_bytes(flashPtr->APD_CONFIG); // Configure APD setting

        SW_Delay(1000);

        unData = CalcExternalBoostTarget(__swap_bytes(flashPtr->APD_TARGET_OUTPUT));
        APDIDX4 = IDX_TARGET; // Target Voltage
        APDDAT4 = unData;
        //        flashPtr->APD_CURRENT_SETTING = __swap_bytes(flashPtr->APD_TARGET_OUTPUT);
        flashPtr->APD_CURRENT_SETTING = __swap_bytes(unData);

        //        APDCN2 =  __swap_bytes(flashPtr->APD_CONFIG);                        //Configure APD setting
      }
      else
      {
        unData = CalcExternalBoostTarget(__swap_bytes(flashPtr->APD_TARGET_OUTPUT));
        APDIDX4 = IDX_TARGET; // Target Voltage
        APDDAT4 = unData;
        //        flashPtr->APD_CURRENT_SETTING = __swap_bytes(flashPtr->APD_TARGET_OUTPUT);
        flashPtr->APD_CURRENT_SETTING = __swap_bytes(unData);

        APDCN4 = __swap_bytes(flashPtr->APD_CONFIG); // Configure APD setting
      }

      APDIDX4 = IDX_DUTY;                          // Duty Cycle
      APDCN4 = __swap_bytes(flashPtr->APD_CONFIG); // Configure APD setting
    }
  }
  else
  {
    APDIDX4 = IDX_DUTY; // Duty Cycle
    APDCN4 = 0;         // disable APD
  }

#endif

#else

  unsigned int unData = 0;
  A2_PAGE_81H_MEMORY_MAP *flashPtr;
  //  A2_PAGE_80H_MEMORY_MAP * flashPtr1

  flashPtr = (A2_PAGE_81H_MEMORY_MAP *)&I2C_Slave_Buffer_A2_P81H_Up[0];

  //  if( PAGE91H_Memory.PMIC_SELECT & APD_ENABLE )
  if ((flashPtr->PMIC_SELECT & APD_ENABLE) == APD_ENABLE) // if TEC is enabled?
  {
    if (~(APDCN2 & 0x0040))
    {
      // Configure APD
      APDIDX2 = IDX_ERRP_START_CLAMP; // Error Start Clamp
      APDDAT2 = __swap_bytes(flashPtr->APD_ERRSTARTCLAMP);

      APDIDX2 = IDX_DUTY_CLAMP; // Duty Clamp
      APDDAT2 = __swap_bytes(flashPtr->APD_DUTYCLAMP);

      APDIDX2 = IDX_INTEGAL_GAIN; // Integral gain
      APDDAT2 = __swap_bytes(flashPtr->APD_INTEGRALGAIN);

      APDIDX2 = IDX_START_DUTY_CLAMP; // Duty Start Clamp
      APDDAT2 = __swap_bytes(flashPtr->APD_DUTYSTARTINCCLAMP);

      APDIDX2 = IDX_CLAMP_INTEGAL; // Integral Clamp
      APDDAT2 = __swap_bytes(flashPtr->APD_INTEGRALCLAMP);

      APDIDX2 = IDX_ERRN_CLAMP; // Error Negative Clamp
      APDDAT2 = __swap_bytes(flashPtr->APD_APDNEGERRCLAMP);

      APDIDX2 = IDX_ERRP_CLAMP; // Error Positive Clamp
      APDDAT2 = __swap_bytes(flashPtr->APD_APDPOSERRCLAMP);
      ;

      APDIDX2 = IDX_PROP_GAIN; // Proportional Gain
      APDDAT2 = __swap_bytes(flashPtr->APD_PROPORTIONALGAIN);

      if (flashPtr->APD_TARGET_OUTPUT > 500)
      {
        unData = CalcExternalBoostTarget(500);
        APDIDX2 = IDX_TARGET; // Target Voltage
        APDDAT2 = unData;
        //        flashPtr->APD_CURRENT_SETTING = __swap_bytes(flashPtr->APD_TARGET_OUTPUT);
        flashPtr->APD_CURRENT_SETTING = __swap_bytes(unData);

        APDCN2 = __swap_bytes(flashPtr->APD_CONFIG); // Configure APD setting

        SW_Delay(1000);

        unData = CalcExternalBoostTarget(__swap_bytes(flashPtr->APD_TARGET_OUTPUT));
        APDIDX2 = IDX_TARGET; // Target Voltage
        APDDAT2 = unData;
        //        flashPtr->APD_CURRENT_SETTING = __swap_bytes(flashPtr->APD_TARGET_OUTPUT);
        flashPtr->APD_CURRENT_SETTING = __swap_bytes(unData);

        //        APDCN2 =  __swap_bytes(flashPtr->APD_CONFIG);                        //Configure APD setting
      }
      else
      {
        unData = CalcExternalBoostTarget(__swap_bytes(flashPtr->APD_TARGET_OUTPUT));
        APDIDX2 = IDX_TARGET; // Target Voltage
        APDDAT2 = unData;
        //        flashPtr->APD_CURRENT_SETTING = __swap_bytes(flashPtr->APD_TARGET_OUTPUT);
        flashPtr->APD_CURRENT_SETTING = __swap_bytes(unData);

        APDCN2 = __swap_bytes(flashPtr->APD_CONFIG); // Configure APD setting
      }

      APDCN2 = __swap_bytes(flashPtr->APD_CONFIG); // Configure APD setting
    }
  }
  else
  {
    APDCN2 = 0; // disable APD
  }

#endif

#else

#endif
}

//-----------------------------------------------------------------------------
// INV_Init function
//   - Initialize invter voltage on APD1
//-----------------------------------------------------------------------------
void INV_Init(void)
{
#if __SFP28_ER__ == 1
#else

  if ((PAGE91H_Memory.PMIC_SELECT & INV_ENABLE) && (PAGE91H_Memory.PMIC_SELECT & BUCK1_ENABLE))
  {
    if (~(APDCN1 & 0x0040))
    {
      // Configure APD
      APDIDX1 = IDX_ERRP_START_CLAMP; // Error Start Clamp
      APDDAT1 = __swap_bytes(PAGE91H_Memory.INV_ERRSTARTCLAMP);

      APDIDX1 = IDX_DUTY_CLAMP; // Duty Clamp
      APDDAT1 = __swap_bytes(PAGE91H_Memory.INV_DUTYCLAMP);

      APDIDX1 = IDX_INTEGAL_GAIN; // Integral gain
      // APDDAT1 = __swap_bytes(PAGE91H_Memory.INV_INTEGRALGAIN);
      APDDAT1 = APD_INIT_KI;

      APDIDX1 = IDX_START_DUTY_CLAMP; // Duty Start Clamp
      APDDAT1 = __swap_bytes(PAGE91H_Memory.INV_DUTYSTARTINCCLAMP);

      APDIDX1 = IDX_CLAMP_INTEGAL; // Integral Clamp
      APDDAT1 = __swap_bytes(PAGE91H_Memory.INV_INTEGRALCLAMP);

      APDIDX1 = IDX_ERRN_CLAMP; // Error Negative Clamp
      APDDAT1 = __swap_bytes(PAGE91H_Memory.INV_APDNEGERRCLAMP);

      APDIDX1 = IDX_ERRP_CLAMP; // Error Positive Clamp
      APDDAT1 = __swap_bytes(PAGE91H_Memory.INV_APDPOSERRCLAMP);

      APDIDX1 = IDX_PROP_GAIN; // Proportional Gain
      // APDDAT1 = __swap_bytes(PAGE91H_Memory.INV_PROPORTIONALGAIN);
      APDDAT1 = APD_INIT_KP;

      APDIDX1 = IDX_TARGET; // Target Voltage
      APDDAT1 = CalcExternalInvTarget(__swap_bytes(PAGE91H_Memory.INV_TARGET_OUTPUT));

      APDCN1 = __swap_bytes(PAGE91H_Memory.INV_APD_CONFIG); // Enable APD with DS mode
    }
  }
  else
  {
    APDCN1 = 0; // disable INV
  }
#endif
}

//-----------------------------------------------------------------------------
// INV_Updata_KPKI function
//   - Update KPKI after Initialization
//-----------------------------------------------------------------------------
void INV_Update_KPKI(void)
{
#if __SFP28_ER__ == 1
#else

  if (PAGE91H_Memory.PMIC_SELECT & INV_ENABLE)
  {
    if (~(APDCN1 & 0x0040))
    {
      APDIDX1 = IDX_INTEGAL_GAIN; // Integral gain
      APDDAT1 = __swap_bytes(PAGE91H_Memory.INV_INTEGRALGAIN);
      APDIDX1 = IDX_PROP_GAIN; // Proportional Gain
      APDDAT1 = __swap_bytes(PAGE91H_Memory.INV_PROPORTIONALGAIN);
    }
  }

#endif
}
//-----------------------------------------------------------------------------
// IDAC_Init function
//   - Initialize idac(For bias generation)
//-----------------------------------------------------------------------------
void IDAC_Init(void)
{
#if __SFP28_ER__ == 1

#if __SFP28_ER_SEMI_TUNABLE__ == 1

#else

  A2_PAGE_81H_MEMORY_MAP *flashPtr;
  //  A2_PAGE_80H_MEMORY_MAP * flashPtr1

  flashPtr = (A2_PAGE_81H_MEMORY_MAP *)&I2C_Slave_Buffer_A2_P81H_Up[0];

  // IDAC2
  IDCD2 = 0;      // set IDAC output to 0
  IDCN2 = 0x0000; // disable IDAC before initialization

  IDCD2 = 0;                                   // set output to 0, APC loop will control the output of IDAC
  IDCN2 = __swap_bytes(flashPtr->IDAC_CONFIG); // set IDAC configuration

#endif

#else

#ifdef DCDC_BIASING // DCDC Biasing mode, IDAC should be disabled.

  IDCN1 = 0;

#else // IDAC biasing

  IDCD1 = 0;      // set IDAC output to 0
  IDCN1 = 0x0000; // disable IDAC before initialization

  DCDC_SEL = DC_DC_CH1; // Select DCDC1

  if (DCCN == DCCNSET) // Check if the DCDC1 is enabled
  {

    IDCD1 = 0;                                         // set output to 0, APC loop will control the output of IDAC
    IDCN1 = __swap_bytes(PAGE90H_Memory.IDAC1_CONFIG); // set IDAC configuration
  }
#endif

#endif
}

//-----------------------------------------------------------------------------
// DSDAC_Init function
//   - Initialize DS-DAC, it's for EA
//-----------------------------------------------------------------------------
void DSDAC_Init(void)
{
#if __SFP28_ER__ == 1

#if __SFP28_ER_SEMI_TUNABLE__ == 1

#else

  // Vcc Compensations Mode ���
  // DAC PWM Control Register (DPCN)
  // DAC PWM Configuration: 0x8040 (Enable/DS DAC Mode/VCC Compensated mode)
  //  unsigned int  dacNo;
  unsigned int dac_conf;
  unsigned int dac_dpduty;
  unsigned int dac_dacfs;

  dac_conf = 0x8040;
  dac_dpduty = 0;
  dac_dacfs = 0; // When operating in VCC Compensated mode, this register should not be written because it will be dynamically adjusted by the DS-DAC controller

  DS_DAC_Init(DSDAC_CH4, dac_conf, dac_dacfs); // init DS-DAC

  RampDS_DAC(DSDAC_CH4, dac_dpduty);

#endif

#else

  DS_DAC_Init(DSDAC_CH4, __swap_bytes(PAGE90H_Memory.DS_DAC4_CONFIG),
              __swap_bytes(PAGE90H_Memory.DS_DAC4_DACFS)); // init DS-DAC

  RampDS_DAC(DSDAC_CH4, __swap_bytes(PAGE90H_Memory.DS_DAC4_DPDUTY));
#endif
}

//-----------------------------------------------------------------------------
// SH_Init function
//   - Initialize Sample and hold
//-----------------------------------------------------------------------------
void SH_Init(void)
{
#if __SFP28_ER__ == 1
#else

  // SH0 Setup
  IEN1_bit.IEN17 = 1;                            // SHEN @GP17
  SHCN = __swap_bytes(PAGE90H_Memory.SH_CONFIG); // set SH configuration
#endif
}

//-----------------------------------------------------------------------------
// I2CMaster_Init function
//   - Initialize i2c master, 400KHz, I2C Master1
//-----------------------------------------------------------------------------
void I2CMaster_Init(void)
{
#if __SFP28_ER__ == 1
#if __HW_I2C_MASTER_ENABLE__ == 1
  //  I2CM_Init (I2CM_MASTER_1, I2CM_CLOCK_DIV_100KHZ, I2CM_MSDA_PIN_GP10, 0);      //Init I2C Master, SDA - GP10, SCL - GP11
  I2CM_Init(I2CM_MASTER_1, I2CM_CLOCK_DIV_400KHZ, I2CM_MSDA_PIN_GP10, 0); // Init I2C Master, SDA - GP10, SCL - GP11
#else
  i2c_master_gpio_init();
#endif

#else

  I2CM_Init(I2CM_MASTER_1, I2CM_CLOCK_DIV_400KHZ, I2CM_MSDA_PIN_GP10, 0); // Init I2C Master, SDA - GP10, SCL - GP11
#endif
}

//-----------------------------------------------------------------------------
// TEC_Init function
//   - Initialize TEC
//-----------------------------------------------------------------------------
void TEC_Init(void)
{
#if __SFP28_ER__ == 1
  TECC_Init(TEC_CH1); // Init TEC 1
//  TECC_Init(TEC_CH2);                                                           //Init TEC 1
#else

  TECC_Init(TEC_CH2); // Init TEC 2
#endif
}

//-----------------------------------------------------------------------------
// PLA_Init function
//   - Initialize pla
//-----------------------------------------------------------------------------
void PLA_Init(void)
{
#if __SFP28_ER__ == 1

#if __SFP28_ER_SEMI_TUNABLE__ == 1
  // TXDIS 이용하여 Cable Sensing 광출력 제어
  // // GP24: TXDIS, Input GP24, Output GP00 (TXDIS_CDR), active high
  // PLACNT1_bit.REG_SEL = 0;
  // PLADAT1 = 0x0010; // PIS[4] = 1, GP24 Input, active high
  // PLACNT1 = 0x80C0; // PLAEN, OUT GP00, SBEN2, SBEN1, REG_SEL(PIS)

  // RX LOS  Ouput GP22, active high, Input (from CDR) GP07, SBEN1, REG_SEL (PIS)
  //  PLACNT2_bit.REG_SEL = 3; // undefined
  //  PLACNT2_bit.REG_SEL = 0; // PIS(Pin Input Select)
  //  PLADAT2 = 0x0008; // PIS[3] = 1, GP07 Input, active high
  ////  PLACNT2 = 0x8643; // PLAEN, OUT GP00, SBEN2, SBEN1, REG_SEL(PIS)-> undefined (CDR���� RX LOS ����� ������� ����
  //  PLACNT2 = 0x86C0; // PLAEN, OUT GP00, SBEN2, SBEN1, REG_SEL(PIS)-> undefined (CDR���� RX LOS ����� ������� ����

  // LOS GP07 (input) -> PG22 (output)
  PLACNT2_bit.REG_SEL = 0; // undefined
  PLADAT2 = 0x0008;        // PIS[3] = 1, GP07 Input, active high
  PLACNT2 = 0x8640;        // PLAEN, OUT PG22, SBEN2, SBEN1, REG_SEL(PIS)-> undefined (CDR���� RX LOS ����� ������� ����

  // TX FAULT Ouput GP23, active high, Input (from CDR) GP05, SBEN2, SBEN1, REG_SEL (PIS)
  PLACNT3_bit.REG_SEL = 0;
  PLADAT3 = 0x0002; // PIS[1] = 1, GP05 Input, active high
  PLACNT3 = 0x87C0; // PLAEN, OUT GP23, SBEN2, SBEN1, REG_SEL(PIS)

#else

#endif

#else

  // TX DIS  Input GP07 Ouput GP03, active high
  PLACNT1_bit.REG_SEL = 0;
  PLADAT1 = __swap_bytes(PAGE90H_Memory.PLA1_INPUT_SEL);
  PLACNT1 = __swap_bytes(PAGE90H_Memory.PLA1_CONFIG);

  // RX LOS  Ouput GP01, active high
  PLACNT2_bit.REG_SEL = 0;
  PLADAT2 = __swap_bytes(PAGE90H_Memory.PLA2_INPUT_SEL);
  PLACNT2 = __swap_bytes(PAGE90H_Memory.PLA2_CONFIG);

  // TX FAULT Ouput GP02, active high
  PLACNT3_bit.REG_SEL = 0;
  PLADAT3 = __swap_bytes(PAGE90H_Memory.PLA3_INPUT_SEL);
  PLACNT3 = __swap_bytes(PAGE90H_Memory.PLA3_CONFIG);
#endif
}

//-----------------------------------------------------------------------------
// PLA_Soft_TXD_Control function
//   - Set PLA1 soft control, 1 or 0
//-----------------------------------------------------------------------------
void PLA_Soft_TXD_Control(unsigned char unControl)
{
#if __SFP28_ER__ == 1

#if __SFP28_ER_SEMI_TUNABLE__ == 1

  __disable_interrupt();

#if __WO_TXDIS_PIN_MONITORING__ == 1

  //  if (MSA_INPUT_TXDIS == ASSERTED)
  //  {
  //    // Asserted TXDIS PIN
  //     PLACNT1_bit.SB1 = 1;                                                       //Set High for TX disable assert
  //  }
  //  else
  if ((I2C_Slave_Buffer_A2[0x6E] & 0x40) == 0x40)
  {
    // Asserted TXDIS PIN
    PLACNT1_bit.SB1 = 1; // Set High for TX disable assert
  }
  else if (unControl == ASSERTED)
  {
    PLACNT1_bit.SB1 = 1; // Set High for TX disable assert
  }
  else
  {
    PLACNT1_bit.SB1 = 0; // Set High for TX disable assert
  }

#else

  //  if (MSA_INPUT_TXDIS == ASSERTED)
  //  {
  //    // Asserted TXDIS PIN
  //     PLACNT1_bit.SB1 = 1;                                                       //Set High for TX disable assert
  //  }
  //  else
  if ((I2C_Slave_Buffer_A2[0x6E] & 0x40) == 0x40)
  {
    // Asserted TXDIS PIN
    PLACNT1_bit.SB1 = 1; // Set High for TX disable assert
  }
  else if (unControl == ASSERTED)
  {
    PLACNT1_bit.SB1 = 1; // Set High for TX disable assert
  }
  else
  {
    PLACNT1_bit.SB1 = 0; // Set High for TX disable assert
  }

#endif

  //  if(unControl == ASSERTED)
  //  {
  //     PLACNT1_bit.SB1 = 1;                                                       //Set High for TX disable assert
  //  }
  //  else
  //  {
  //     PLACNT1_bit.SB1 = 0;                                                       //Set Low for TX disable de-assert
  //  }

  __enable_interrupt();

#else

#endif

#else

  if (unControl == ASSERTED)
  {
    PLACNT1_bit.SB1 = 1; // Set High for TX disable assert
  }
  else
  {
    PLACNT1_bit.SB1 = 0; // Set Low for TX disable de-assert
  }
#endif
}

void PLA_Soft_TXD_Control_forced(unsigned char unControl)
{
#if __SFP28_ER__ == 1

#if __SFP28_ER_SEMI_TUNABLE__ == 1

  __disable_interrupt();

  if (unControl == ASSERTED)
  {
    PLACNT1_bit.SB1 = 1; // Set High for TX disable assert
  }
  else
  {
    PLACNT1_bit.SB1 = 0; // Set Low for TX disable de-assert
  }

  __enable_interrupt();

#else

#endif

#else

  if (unControl == ASSERTED)
  {
    PLACNT1_bit.SB1 = 1; // Set High for TX disable assert
  }
  else
  {
    PLACNT1_bit.SB1 = 0; // Set Low for TX disable de-assert
  }
#endif
}

void PLA_Pin_TXD_Control(unsigned char unControl)
{
#if __SFP28_ER__ == 1

#if __SFP28_ER_SEMI_TUNABLE__ == 1
  __disable_interrupt();

  //  if(unControl == ASSERTED)
  //  {
  //     PLACNT1_bit.SB1 = 1;                                                       //Set High for TX disable assert
  //  }
  //  else
  //  {
  //     PLACNT1_bit.SB1 = 0;                                                       //Set Low for TX disable de-assert
  //  }

#if __WO_TXDIS_PIN_MONITORING__ == 1

  //  if (MSA_INPUT_TXDIS == ASSERTED)
  //   {
  //    // Asserted TXDIS PIN
  //     PLACNT1_bit.SB1 = 1;                                                       //Set High for TX disable assert
  //  }
  //  else
  if ((I2C_Slave_Buffer_A2[0x6E] & 0x40) == 0x40)
  {
    // Asserted TXDIS PIN
    PLACNT1_bit.SB1 = 1; // Set High for TX disable assert
  }
  else
  {
    PLACNT1_bit.SB1 = 0; // Set High for TX disable assert
  }

#else

  if (MSA_INPUT_TXDIS == ASSERTED)
  {
    // Asserted TXDIS PIN
    PLACNT1_bit.SB1 = 1; // Set High for TX disable assert
  }
  else if ((I2C_Slave_Buffer_A2[0x6E] & 0x40) == 0x40)
  {
    // Asserted TXDIS PIN
    PLACNT1_bit.SB1 = 1; // Set High for TX disable assert
  }
  else
  {
    PLACNT1_bit.SB1 = 0; // Set High for TX disable assert
  }

#endif

  __enable_interrupt();

#else

#endif

#else
  __disable_interrupt();

  if (unControl == ASSERTED)
  {
    PLACNT1_bit.SB2 = 1; // Set High for TX disable assert
  }
  else
  {
    PLACNT1_bit.SB2 = 0; // Set Low for TX disable de-assert
  }

  __enable_interrupt();

#endif
}

//-----------------------------------------------------------------------------
// ReadWaitingI2C function
//   - return s_unWaiting_I2C status
//-----------------------------------------------------------------------------
unsigned int ReadWaitingI2C(void)
{
  return s_unWaiting_I2C; // return i2c master arbitration status
}

//-----------------------------------------------------------------------------
// WriteWaitingI2C function
//   - configure s_unWaiting_I2C
//-----------------------------------------------------------------------------
void WriteWaitingI2C(unsigned int unData)
{
  s_unWaiting_I2C = unData; // update i2c master arbitration status
}

//-----------------------------------------------------------------------------
// MasterI2CArbitration function
//   - All I2C master operations are in this function
//-----------------------------------------------------------------------------
void MasterI2CArbitration(void)
{
#if __SFP28_ER__ == 1
  // Control and Access MALD-37845 CDR
  static unsigned int s_unI2c_2_clear = 0;

  __disable_interrupt();
  s_unI2c_2_clear |= s_unWaiting_I2C; // Save register
  s_unWaiting_I2C = 0;                // Clear flags
  __enable_interrupt();

  polled_write_entry();
  //  *((unsigned int *)&I2C_Slave_Buffer_A2_P02H_Up[0x42]) = __swap_bytes(write_i2c_count); // for DEBUG, 191104

#else

  static unsigned int s_unI2c_2_clear = 0;

  __disable_interrupt();
  s_unI2c_2_clear |= s_unWaiting_I2C; // Save register
  s_unWaiting_I2C = 0;                // Clear flags
  __enable_interrupt();

  if (s_unI2c_2_clear & WRITE_RESET) // if softe reset Max24016��
  {
    Driver_SoftReset(DRIVER_SLAVE_ADDR, &DRIVER_Memory); // Reset Max24016
    s_unI2c_2_clear &= ~WRITE_RESET;                     // clear flag after this operation is executed.
  }
  else if (s_unI2c_2_clear & WRITE_TX_CNTL)
  {
    Driver_TXControlRegsWrite(DRIVER_SLAVE_ADDR, &DRIVER_Memory);
    s_unI2c_2_clear &= ~WRITE_TX_CNTL;
  }
  else if (s_unI2c_2_clear & WRITE_TOPCTRL)
  {
    Driver_TopCtrlRegsWrite(DRIVER_SLAVE_ADDR, &DRIVER_Memory);
    s_unI2c_2_clear &= ~WRITE_TOPCTRL;
  }
  else if (s_unI2c_2_clear & WRITE_TX_CONFIG)
  {
    Driver_TXRegsWrite(DRIVER_SLAVE_ADDR, &DRIVER_Memory);
    s_unI2c_2_clear &= ~WRITE_TX_CONFIG;
  }
  else if (s_unI2c_2_clear & WRITE_RX_CONFIG)
  {
    Driver_RXRegsWrite(DRIVER_SLAVE_ADDR, &DRIVER_Memory);
    s_unI2c_2_clear &= ~WRITE_RX_CONFIG;
  }
  else if (s_unI2c_2_clear & WRITE_CONTROL)
  {
    Driver_ControlRegsWrite(DRIVER_SLAVE_ADDR, &DRIVER_Memory);
    s_unI2c_2_clear &= ~WRITE_CONTROL;
  }
  else if (s_unI2c_2_clear & WRITE_TX_SET_EQ)
  {
    // Reserved for further use
    s_unI2c_2_clear &= ~WRITE_TX_SET_EQ;
  }
  else if (s_unI2c_2_clear & WRITE_RX_SET_PE)
  {
    // Reserved for further use
    s_unI2c_2_clear &= ~WRITE_RX_SET_PE;
  }
  else if (s_unI2c_2_clear & WRITE_TX_MOD)
  {
    Driver_TXModWrite(DRIVER_SLAVE_ADDR, &DRIVER_Memory);
    s_unI2c_2_clear &= ~WRITE_TX_MOD;
  }
  else if (s_unI2c_2_clear & WRITE_TX_BIAS)
  {
    Driver_TXBiasWrite(DRIVER_SLAVE_ADDR, &DRIVER_Memory);
    s_unI2c_2_clear &= ~WRITE_TX_BIAS;
  }
  else
  {
  }
#endif
}

//-----------------------------------------------------------------------------
// write_bias function
//   - update bias( IDAC or DCDC1)
//-----------------------------------------------------------------------------
void write_bias(unsigned int unBias)
{
#if __SFP28_ER__ == 1
#else

#ifdef DCDC_BIASING // DCDC Bising

  unsigned int unPI_Enable = __swap_bytes(PAGE91H_Memory.BUCK_PI_CTRL);

  if (unBias > __swap_bytes(PAGE91H_Memory.BUCK_MAX_DCDC2)) // Max DCDC output limitation
  {
    unBias = __swap_bytes(PAGE91H_Memory.BUCK_MAX_DCDC2);
  }

  DCDC_SEL = DC_DC_CH2; // Select DCDC2

  if (DCCN == DCCNSET) // if DCDC2 is enabled, implement following instructions
  {
    if (unPI_Enable & 0x8000) // checking PI mode is enabled?
    {
      DCDC_SEL = DC_DC_CH2;
      PI_Config(PI_INDEX_SETPOINT, CalcPIBuckTarget(unBias));
    }
    else
    {
      unBias = CalcBuckTarget(unBias); // Convert the input value into Buck Target

      if (unBias > __swap_bytes(PAGE91H_Memory.BUCK_MAX_DCDC2))
      {
        unBias = __swap_bytes(PAGE91H_Memory.BUCK_MAX_DCDC2);
      }

      DCDC_SEL = DC_DC_CH2;

      if (unBias != VRDCDC)
      {
        __disable_interrupt();
        DCDC_SEL = DC_DC_CH2;
        VRDCDC = unBias;
        __enable_interrupt();
      }
    }

    PAGEA0H_Memory.BIAS_CURRENT_SETTING = __swap_bytes(VRDCDC);                 // Update current Bias setting to readout table 0xA0
    UpdateWordA2hTable(PAGE_A0H, &PAGEA0H_Memory.BIAS_CURRENT_SETTING, VRDCDC); // Update current Bias setting to A2h Higher RAM if current table is 0xA0
  }

#else // IDAC Bising

  if (unBias > __swap_bytes(PAGE90H_Memory.IDAC1_MAXOUTPUT)) // Max DCDC output limitation
  {
    unBias = __swap_bytes(PAGE90H_Memory.IDAC1_MAXOUTPUT);
  }

  DCDC_SEL = DC_DC_CH1; // Select DCDC 1

  if ((IDCN1 & 0x0001) && (DCCN == DCCNSET)) // check if IDAC and DCDC1 are enabled
  {
    unBias = unBias;
  }
  else
  {
    unBias = 0; // if IDAC and DCDC1 are disabled, set Bias to 0
  }

  if (unBias > BIAS_MAX) // Max Bias checking(internal use), customer can change BIAS_MAX for their application,
  {

    unBias = BIAS_MAX;
  }

  if (unBias != IDCD1) // if not equal, update IDCD1
  {

    __disable_interrupt(); // disable interrupt before updating IDAC, some operation in ISR may update IDAC too
    IDCD1 = unBias;        // Update IDCD1
    __enable_interrupt();  // enable interrupt
  }

  PAGEA0H_Memory.BIAS_CURRENT_SETTING = __swap_bytes(IDCD1);                 // Update current Bias setting to readout table 0xA0
  UpdateWordA2hTable(PAGE_A0H, &PAGEA0H_Memory.BIAS_CURRENT_SETTING, IDCD1); // Update current Bias setting to A2h Higher RAM if current table is 0xA0

#endif

#endif
}

//-----------------------------------------------------------------------------
// write_mod function
//   - update mod (MAX24016)
//-----------------------------------------------------------------------------
void write_mod(unsigned int ucMod)
{
#if __SFP28_ER__ == 1
#else

  if (ucMod > MOD_MAX) // Max mod checking(internal use), customer can change MOD_MAX for their application,
  {
    ucMod = MOD_MAX;
  }

  DRIVER_Memory.SET_MOD0 = ucMod << 7;
  DRIVER_Memory.SET_MOD1 = ucMod >> 1;

  Driver_TXModWrite(DRIVER_SLAVE_ADDR, &DRIVER_Memory); // update mod

  PAGEA0H_Memory.MOD_CURRENT_SETTING = __swap_bytes(ucMod);                 // Update current Bias setting to readout table 0xA0
  UpdateWordA2hTable(PAGE_A0H, &PAGEA0H_Memory.MOD_CURRENT_SETTING, ucMod); // Update current Bias setting to A2h Higher RAM if current table is 0xA0
#endif
}

//-----------------------------------------------------------------------------
// Ramp DS_DAC function
//   - ramp DS_DAC
//-----------------------------------------------------------------------------
/*
void RampDS_DAC(unsigned int unChannel, unsigned int unTarget)
{
  int sError = 0;
  unsigned int unOutput = 0;

  unError = unTarget - unStart;
  unOutput = unStart + unError/2;

  DS_DAC_Duty(unChannel, unOutput);
  SW_Delay(200);
  DS_DAC_Duty(unChannel, unTarget);

}
*/

//-----------------------------------------------------------------------------
// end of file
//-----------------------------------------------------------------------------
